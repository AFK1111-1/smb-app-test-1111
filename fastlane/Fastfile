# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tool

default_platform(:android)

platform :android do
  desc "Build Android debug APK for development"
  lane :dev_build do
    gradle(task: "clean assembleRelease", project_dir: "./android", properties: {
      "android.injected.signing.store.file" => "#{Dir.pwd}/../credentials/android/release.keystore",
      "android.injected.signing.store.password" => ENV['ANDROID_KEYSTORE_PASSWORD'],
      "android.injected.signing.key.alias" => ENV['ANDROID_KEY_ALIAS'],
      "android.injected.signing.key.password" => ENV['ANDROID_KEY_PASSWORD']
    })
  end

  desc "Submit a new internal test build to play store"
  lane :qa_release do
    previous_build_number = google_play_track_version_codes(
      track: "internal",
      json_key: "credentials/android/google-play-service-key.json"
    )[0]

    increment_version_name(
      gradle_file_path: "android/app/build.gradle"
    )
    increment_version_code(
      gradle_file_path: "android/app/build.gradle",
      version_code: previous_build_number + 1
    )

    gradle(task: "clean bundleRelease", project_dir: "./android", properties: {
      "android.injected.signing.store.file" => "#{Dir.pwd}/../credentials/android/release.keystore",
      "android.injected.signing.store.password" => ENV['ANDROID_KEYSTORE_PASSWORD'],
      "android.injected.signing.key.alias" => ENV['ANDROID_KEY_ALIAS'],
      "android.injected.signing.key.password" => ENV['ANDROID_KEY_PASSWORD']
    })

    upload_to_play_store(
      track: 'internal',
      json_key: "credentials/android/google-play-service-key.json",
      aab: "android/app/build/outputs/bundle/release/app-release.aab"
    )

    changelog_from_git_commits
  end

  desc "Submit a new production build to play store"
  lane :production_release do
    increment_version_name(
      gradle_file_path: "android/app/build.gradle"
    )
    increment_version_code(
      gradle_file_path: "android/app/build.gradle"
    )

    gradle(task: "clean bundleRelease", project_dir: "./android", properties: {
      "android.injected.signing.store.file" => "#{Dir.pwd}/../credentials/android/release.keystore",
      "android.injected.signing.store.password" => ENV['ANDROID_KEYSTORE_PASSWORD'],
      "android.injected.signing.key.alias" => ENV['ANDROID_KEY_ALIAS'],
      "android.injected.signing.key.password" => ENV['ANDROID_KEY_PASSWORD']
    })

    upload_to_play_store(
      track: 'production',
      release_status: "draft",
      json_key: "credentials/android/google-play-service-key.json",
      aab: "android/app/build/outputs/bundle/release/app-release.aab"
    )
  end
end

platform :ios do

  desc "Build iOS simulator app for development"
  lane :dev_build do
    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      sdk: "iphonesimulator",
      configuration: "Debug",
      derived_data_path: "ios/build",
      output_directory: "ios/build",
      output_name: "smbmobile.app"
    )
  end

  desc "Submit a new QA build to TestFlight"
  lane :qa_release do
    # ===== DIAGNOSTIC LOGGING START =====
    puts "=" * 80
    puts "üîç iOS QA Release Build - Diagnostic Information"
    puts "=" * 80
    
    # Log environment information
    puts "\nüìã Environment Information:"
    puts "  - Ruby Version: #{RUBY_VERSION}"
    puts "  - Fastlane Version: #{Fastlane::VERSION}"
    puts "  - Working Directory: #{Dir.pwd}"
    puts "  - Xcode Path: #{`xcode-select -p`.strip}"
    puts "  - Xcode Version: #{`xcodebuild -version`.lines.first.strip}"
    
    # Log Xcode version details
    xcode_info = `xcodebuild -version`.strip
    puts "\nüõ† Xcode Details:"
    xcode_info.lines.each { |line| puts "  #{line.strip}" }
    
    # Check for iOS workspace and scheme
    puts "\nüìÅ Project Structure:"
    if File.exist?("ios/smbmobile.xcworkspace")
      puts "  ‚úÖ Workspace found: ios/smbmobile.xcworkspace"
    else
      puts "  ‚ùå Workspace NOT found: ios/smbmobile.xcworkspace"
    end
    
    if File.exist?("ios/smbmobile.xcodeproj")
      puts "  ‚úÖ Project found: ios/smbmobile.xcodeproj"
    else
      puts "  ‚ùå Project NOT found: ios/smbmobile.xcodeproj"
    end
    
    # Log environment variables (sanitized)
    puts "\nüîê Environment Variables (sanitized):"
    puts "  - APP_STORE_CONNECT_API_KEY_ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID'] ? '‚úÖ Set' : '‚ùå Not Set'}"
    puts "  - APP_STORE_CONNECT_ISSUER_ID: #{ENV['APP_STORE_CONNECT_ISSUER_ID'] ? '‚úÖ Set' : '‚ùå Not Set'}"
    puts "  - KEYCHAIN_PASSWORD: #{ENV['KEYCHAIN_PASSWORD'] ? '‚úÖ Set' : '‚ùå Not Set'}"
    puts "  - KEYCHAIN_NAME: #{ENV['KEYCHAIN_NAME'] ? '‚úÖ Set' : '‚ùå Not Set'}"
    
    # Check Podfile and Pods
    puts "\nüì¶ CocoaPods Status:"
    if File.exist?("ios/Podfile")
      puts "  ‚úÖ Podfile found"
      podfile_content = File.read("ios/Podfile")
      puts "  - Podfile size: #{podfile_content.length} bytes"
      if podfile_content.include?("post_install")
        puts "  ‚úÖ post_install hook present"
      else
        puts "  ‚ö†Ô∏è  post_install hook NOT found"
      end
    else
      puts "  ‚ùå Podfile NOT found"
    end
    
    if File.exist?("ios/Podfile.lock")
      puts "  ‚úÖ Podfile.lock found"
    else
      puts "  ‚ö†Ô∏è  Podfile.lock NOT found"
    end
    
    if Dir.exist?("ios/Pods")
      puts "  ‚úÖ Pods directory exists"
      rnfb_messaging_path = "ios/Pods/RNFBMessaging"
      if Dir.exist?(rnfb_messaging_path)
        puts "  ‚úÖ RNFBMessaging pod found"
      else
        puts "  ‚ö†Ô∏è  RNFBMessaging pod NOT found"
      end
    else
      puts "  ‚ö†Ô∏è  Pods directory NOT found"
    end
    
    puts "=" * 80
    puts "\n"
    # ===== DIAGNOSTIC LOGGING END =====

    # Fail-fast checks for critical files
    puts "\nüîç Running fail-fast checks..."
    missing_items = []
    
    unless File.exist?("ios/smbmobile.xcworkspace")
      missing_items << "ios/smbmobile.xcworkspace"
    end
    
    unless File.exist?("ios/smbmobile.xcodeproj")
      missing_items << "ios/smbmobile.xcodeproj"
    end
    
    unless File.exist?("ios/Podfile")
      missing_items << "ios/Podfile"
    end
    
    unless Dir.exist?("ios/Pods")
      missing_items << "ios/Pods directory"
    end
    
    unless missing_items.empty?
      puts "\n‚ùå CRITICAL ERROR: Missing required iOS project files:"
      missing_items.each { |item| puts "  - #{item}" }
      puts "\nüí° Possible solutions:"
      puts "  1. Ensure 'expo prebuild --platform ios' has been run successfully"
      puts "  2. Ensure 'pod install' has completed in the ios directory"
      puts "  3. Check that you're running from the project root directory"
      puts "  4. Review the prebuild logs for any errors"
      puts "\n" + "=" * 80
      UI.user_error!("iOS project files are missing. Please run prebuild before building.")
    end
    
    puts "‚úÖ All critical files present\n"

    # Setup App Store Connect API authentication
    puts "\nüîë Setting up App Store Connect API authentication..."
    api_key = app_store_connect_api_key(
      key_id: ENV['APP_STORE_CONNECT_API_KEY_ID'],
      issuer_id: ENV['APP_STORE_CONNECT_ISSUER_ID'],
      key_filepath: "#{Dir.pwd}/../credentials/ios/AuthKey.p8"
    )
    puts "‚úÖ API Key configured successfully\n"

    # Fetch App Store provisioning profiles and certificates from private Git repo
    puts "\nüì± Fetching provisioning profiles and certificates..."
    match(
      type: "appstore",
      readonly: false,
      app_identifier: "com.insighture.smbmobile",
      git_url: "git@github.com:insighture/smb-mobile-fastlane.git",
      api_key: api_key,
      force_for_new_devices: true,
      keychain_password: ENV['KEYCHAIN_PASSWORD'],
      keychain_name: ENV['KEYCHAIN_NAME']
    )
    puts "‚úÖ Provisioning profiles fetched successfully\n"
    
    puts "\nüîê Updating code signing settings..."
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "ios/smbmobile.xcodeproj",
      team_id: "96W7U4JYV4",
      profile_name: "match AppStore com.insighture.smbmobile",
      code_sign_identity: "iPhone Distribution",
      targets: ["smbmobile"]
    )
    puts "‚úÖ Code signing configured successfully\n"

    # Increment version number
    puts "\nüî¢ Incrementing version number..."
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    current_version = get_version_number(xcodeproj: "ios/smbmobile.xcodeproj")
    puts "‚úÖ Version updated to: #{current_version}\n"
    
    # Get latest TestFlight build and increment
    puts "\nüî¢ Fetching and incrementing build number..."
    begin
      latest_build = latest_testflight_build_number(
        app_identifier: "com.insighture.smbmobile",
        api_key: api_key
      )
      puts "  - Latest TestFlight build: #{latest_build}"
      increment_build_number(
        xcodeproj: "ios/smbmobile.xcodeproj",
        build_number: latest_build + 1
      )
      puts "‚úÖ Build number set to: #{latest_build + 1}\n"
    rescue => ex
      puts "‚ö†Ô∏è  Could not fetch latest build number: #{ex.message}"
      puts "  Using default increment..."
      increment_build_number(xcodeproj: "ios/smbmobile.xcodeproj")
      current_build = get_build_number(xcodeproj: "ios/smbmobile.xcodeproj")
      puts "‚úÖ Build number set to: #{current_build}\n"
    end

    # Log current version and build number
    final_version = get_version_number(xcodeproj: "ios/smbmobile.xcodeproj")
    final_build = get_build_number(xcodeproj: "ios/smbmobile.xcodeproj")
    puts "\nüì± Final Build Information:"
    puts "  - Version: #{final_version}"
    puts "  - Build: #{final_build}"
    puts ""

    # Verify Podfile has the required fixes before building
    puts "\nüîç Verifying Podfile Configuration..."
    podfile_path = "ios/Podfile"
    if File.exist?(podfile_path)
      podfile_content = File.read(podfile_path)
      
      puts "  Checking for required post_install hooks..."
      required_settings = {
        'post_install do |installer|' => 'Post-install hook',
        'SWIFT_OPTIMIZATION_LEVEL' => 'Swift optimization fix',
        'CLANG_ENABLE_MODULE_VERIFIER' => 'Module verifier fix',
        'RNFB' => 'Firebase-specific fixes',
        'IPHONEOS_DEPLOYMENT_TARGET' => 'Deployment target fix'
      }
      
      missing_settings = []
      required_settings.each do |setting, description|
        if podfile_content.include?(setting)
          puts "  ‚úÖ #{description} present"
        else
          puts "  ‚ùå #{description} MISSING"
          missing_settings << description
        end
      end
      
      if missing_settings.any?
        puts "\n  ‚ö†Ô∏è  WARNING: Podfile is missing required fixes:"
        missing_settings.each { |s| puts "    - #{s}" }
        puts "\n  üí° You may need to run: npx expo prebuild --clean"
        puts "     This will regenerate the iOS project with correct settings"
      else
        puts "  ‚úÖ All required Podfile fixes are present"
      end
      
      # Display relevant parts of post_install
      if podfile_content.include?('post_install')
        puts "\n  üìã Post-install hook preview:"
        post_install_section = podfile_content[/post_install.*?^end$/m]
        if post_install_section
          # Show first 30 lines of post_install
          lines = post_install_section.lines.first(30)
          lines.each { |line| puts "    #{line.chomp}" }
          if post_install_section.lines.length > 30
            puts "    ... (#{post_install_section.lines.length - 30} more lines)"
          end
        end
      end
    else
      puts "  ‚ùå Podfile not found at: #{podfile_path}"
      puts "     This is a critical error - iOS build cannot proceed"
    end
    puts ""
    
    # Check and log build settings before building
    puts "\nüîç Checking Build Settings..."
    begin
      build_settings_output = `xcodebuild -workspace ios/smbmobile.xcworkspace -scheme smbmobile -configuration Release -showBuildSettings 2>&1`
      
      # Extract relevant settings
      puts "\nüìã Key Build Settings:"
      relevant_settings = [
        'SWIFT_VERSION',
        'SWIFT_OPTIMIZATION_LEVEL',
        'SWIFT_COMPILATION_MODE',
        'ENABLE_BITCODE',
        'CLANG_ENABLE_MODULE_VERIFIER',
        'CLANG_ENABLE_EXPLICIT_MODULES',
        'IPHONEOS_DEPLOYMENT_TARGET',
        'CODE_SIGN_IDENTITY',
        'PROVISIONING_PROFILE_SPECIFIER'
      ]
      
      relevant_settings.each do |setting|
        matches = build_settings_output.scan(/#{setting} = (.+)/)
        if matches.any?
          puts "  - #{setting}: #{matches.first.first.strip}"
        end
      end
      
      # Check for RNFBMessaging specific settings
      puts "\nüì¶ Checking RNFBMessaging Pod Settings..."
      rnfb_settings = build_settings_output.lines.select { |line| line.include?('RNFBMessaging') }
      if rnfb_settings.any?
        puts "  ‚úÖ RNFBMessaging found in build settings"
      else
        puts "  ‚ö†Ô∏è  RNFBMessaging not found in build settings"
      end
      
    rescue => ex
      puts "‚ö†Ô∏è  Could not retrieve build settings: #{ex.message}"
    end
    puts ""

    # Build configuration
    puts "\nüèó Build Configuration:"
    build_config = {
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      configuration: "Release",
      export_method: "app-store",
      output_directory: "./ios/build",
      output_name: "smbmobile.ipa",
      destination: "generic/platform=iOS",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        },
        teamID: "96W7U4JYV4"
      },
      xcargs: "ONLY_ACTIVE_ARCH=NO ENABLE_BITCODE=NO COMPILER_INDEX_STORE_ENABLE=NO",
      skip_profile_detection: true,
      verbose: true,
      buildlog_path: "./ios/build/logs"
    }
    
    puts "  - Workspace: #{build_config[:workspace]}"
    puts "  - Scheme: #{build_config[:scheme]}"
    puts "  - Configuration: #{build_config[:configuration]}"
    puts "  - Export Method: #{build_config[:export_method]}"
    puts "  - XCArgs: #{build_config[:xcargs]}"
    puts "  - Output: #{build_config[:output_directory]}/#{build_config[:output_name]}"
    puts "  - Build Logs: #{build_config[:buildlog_path]}"
    puts ""

    # Build and archive
    puts "\nüöÄ Starting iOS Archive Build..."
    puts "=" * 80
    begin
      build_ios_app(build_config)
      puts "\n" + "=" * 80
      puts "‚úÖ BUILD SUCCESSFUL"
      puts "=" * 80
    rescue => ex
      puts "\n" + "=" * 80
      puts "‚ùå BUILD FAILED"
      puts "=" * 80
      puts "\nüìã Error Details:"
      puts "  - Error: #{ex.message}"
      puts "\nüîç Checking build logs for detailed error information..."
      
      # Try to find and display the build log
      log_content = nil
      latest_log = nil
      
      if Dir.exist?("./ios/build/logs")
        log_files = Dir.glob("./ios/build/logs/**/*.log")
        if log_files.any?
          puts "\nüìÑ Build Log Files Found:"
          log_files.each { |f| puts "  - #{f}" }
          
          # Display the last log file (most recent)
          latest_log = log_files.max_by { |f| File.mtime(f) }
          log_content = File.read(latest_log)
          
          puts "\nüìñ Analyzing Build Log: #{latest_log}"
          puts "-" * 80
          
          # Extract error lines
          error_lines = []
          log_content.lines.each_with_index do |line, index|
            if line =~ /error:|fatal error:|‚ùå|üõë|\*\* ARCHIVE FAILED \*\*/i
              # Get context around error (10 lines before and after)
              start_idx = [0, index - 10].max
              end_idx = [log_content.lines.length - 1, index + 10].min
              error_lines.concat(log_content.lines[start_idx..end_idx])
              error_lines << "\n--- Error Context End ---\n"
            end
          end
          
          if error_lines.any?
            puts "\nüî¥ ERROR DETAILS FROM BUILD LOG:"
            puts error_lines.uniq.join
          else
            puts "\n‚ö†Ô∏è  No specific error markers found, showing last 150 lines:"
            puts log_content.lines.last(150).join
          end
          puts "-" * 80
        else
          puts "  ‚ö†Ô∏è  No log files found in ./ios/build/logs/"
        end
      else
        puts "  ‚ö†Ô∏è  Build logs directory not found: ./ios/build/logs/"
      end
      
      # Look for specific error patterns in both exception and log
      puts "\nüîç Analyzing Error Patterns:"
      full_error_text = "#{ex.message} #{log_content}".downcase
      
      found_issues = []
      
      if full_error_text.include?('swift_optimization_level')
        found_issues << "SWIFT_OPTIMIZATION_LEVEL mismatch"
        puts "  ‚ö†Ô∏è  SWIFT_OPTIMIZATION_LEVEL mismatch detected"
        puts "     Issue: Different optimization levels between targets"
        puts "     Solution: Podfile post_install hook should normalize this"
      end
      
      if full_error_text.include?('rnfbmessaging')
        found_issues << "RNFBMessaging compilation error"
        puts "  ‚ö†Ô∏è  RNFBMessaging compilation error detected"
        puts "     Issue: Firebase messaging module failing to compile"
        puts "     Check: Firebase SDK version compatibility"
      end
      
      if full_error_text.include?('firebase') && !found_issues.include?("RNFBMessaging compilation error")
        found_issues << "Firebase-related error"
        puts "  ‚ö†Ô∏è  Firebase-related error detected"
        puts "     Check: Firebase dependencies and versions"
      end
      
      if full_error_text =~ /module.*not found|module.*error/
        found_issues << "Module compilation error"
        puts "  ‚ö†Ô∏è  Module compilation/import error detected"
        puts "     Issue: Module precompilation or import failure"
        puts "     Solution: Check CLANG_ENABLE_MODULE_VERIFIER settings"
      end
      
      if full_error_text.include?('usernotifications')
        found_issues << "UserNotifications framework issue"
        puts "  ‚ö†Ô∏è  UserNotifications framework issue detected"
        puts "     Issue: Missing or incorrect UserNotifications import"
        puts "     Solution: Check framework imports in RNFBMessaging"
      end
      
      if full_error_text.include?('undeclared identifier') || full_error_text.include?('unknown type name')
        found_issues << "Missing type/identifier"
        puts "  ‚ö†Ô∏è  Undeclared identifier or unknown type detected"
        puts "     Issue: Missing import or header file"
        puts "     Solution: Check header imports and framework linking"
      end
      
      if found_issues.empty?
        puts "  ‚ÑπÔ∏è  No specific error patterns identified"
        puts "     Review the detailed error log above"
      end
      
      puts "\nüí° Recommended Troubleshooting Steps:"
      puts "  1. Check the detailed error context above for the root cause"
      puts "  2. Verify 'pod install' ran successfully after Podfile changes"
      puts "  3. Check if Podfile post_install hooks are properly configured"
      puts "  4. Verify Firebase pod versions are compatible with Xcode 16.1"
      puts "  5. Check if RNFBMessaging source files have correct imports"
      puts "  6. Try cleaning: cd ios && pod deintegrate && pod install"
      puts ""
      
      # Save error summary to file for debugging
      if latest_log
        summary_file = "./ios/build/logs/error_summary.txt"
        File.write(summary_file, "=" * 80 + "\n")
        File.write(summary_file, "BUILD ERROR SUMMARY\n", mode: 'a')
        File.write(summary_file, "=" * 80 + "\n", mode: 'a')
        File.write(summary_file, "Time: #{Time.now}\n", mode: 'a')
        File.write(summary_file, "Error: #{ex.message}\n", mode: 'a')
        File.write(summary_file, "Issues Found: #{found_issues.join(', ')}\n", mode: 'a')
        File.write(summary_file, "=" * 80 + "\n", mode: 'a')
        puts "üìù Error summary saved to: #{summary_file}"
      end
      
      raise ex
    end

    # Upload to TestFlight with auto-retry on duplicate build errors
    puts "\nüì§ Uploading to TestFlight..."
    max_retries = 3
    retry_count = 0
    upload_success = false
    
    while retry_count < max_retries && !upload_success
      begin
        puts "  - Attempt #{retry_count + 1} of #{max_retries}"
        upload_to_testflight(
          skip_waiting_for_build_processing: true,
          api_key: api_key
        )
        upload_success = true
        puts "‚úÖ Upload successful!\n"
      rescue => ex
        puts "‚ö†Ô∏è  Upload attempt #{retry_count + 1} failed: #{ex.message}"
        
        if ex.message.include?("bundle version must be higher") || ex.message.include?("DUPLICATE")
          retry_count += 1
          
          if retry_count < max_retries
            puts "  - Incrementing build number and retrying..."
            current_build = get_build_number(xcodeproj: "ios/smbmobile.xcodeproj")
            increment_build_number(
              xcodeproj: "ios/smbmobile.xcodeproj",
              build_number: current_build.to_i + 1
            )
            puts "  - New build number: #{current_build.to_i + 1}"
            puts "  - Rebuilding..."
            build_ios_app(build_config)
          else
            puts "‚ùå Max retries reached"
            raise ex
          end
        else
          raise ex
        end
      end
    end

    puts "\nüìù Generating changelog from git commits..."
    changelog_from_git_commits
    
    puts "\n" + "=" * 80
    puts "‚úÖ QA RELEASE COMPLETED SUCCESSFULLY"
    puts "=" * 80
    puts "  - Version: #{final_version}"
    puts "  - Build: #{final_build}"
    puts "  - Upload: Successful"
    puts "=" * 80
  end

  desc "Submit a new staging build to TestFlight"
  lane :stg_release do
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    increment_build_number(
      xcodeproj: "ios/smbmobile.xcodeproj"
    )

    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        }
      },
      output_directory: "ios/build",
      output_name: "smbmobile.ipa",
      team_id: ENV['APPLE_TEAM_ID'] || "96W7U4JYV4"
    )

    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )

    changelog_from_git_commits
  end

  desc "Submit a new production build to App Store"
  lane :production_release do
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    increment_build_number(
      xcodeproj: "ios/smbmobile.xcodeproj"
    )

    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        }
      },
      output_directory: "ios/build",
      output_name: "smbmobile.ipa",
      team_id: ENV['APPLE_TEAM_ID'] || "96W7U4JYV4"
    )

    upload_to_app_store(
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false
    )

    changelog_from_git_commits
  end

  desc "Submit a new production build to App Store (legacy)"
  lane :release do
    increment_version_number(
      xcodeproj: "ios/smbmobile.xcodeproj",
      bump_type: "patch"
    )
    increment_build_number(
      xcodeproj: "ios/smbmobile.xcodeproj"
    )

    build_ios_app(
      workspace: "ios/smbmobile.xcworkspace",
      scheme: "smbmobile",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.insighture.smbmobile" => "match AppStore com.insighture.smbmobile"
        }
      },
      output_directory: "ios/build",
      output_name: "smbmobile.ipa",
      team_id: ENV['APPLE_TEAM_ID'] || "96W7U4JYV4"
    )

    upload_to_app_store(
      skip_metadata: true,
      skip_screenshots: true,
      precheck_include_in_app_purchases: false
    )

    changelog_from_git_commits
  end
end